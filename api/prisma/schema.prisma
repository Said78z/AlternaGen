// Prisma schema for AlternaGen MVP PRO
// Database: PostgreSQL 15

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// 1. CORE IDENTITY & BILLING
// ============================================

model User {
  id        String   @id @default(uuid())
  clerkId   String   @unique @map("clerk_id")
  email     String   @unique
  firstName String?  @map("first_name")
  lastName  String?  @map("last_name")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // MVP 2 Relations
  subscription Subscription?
  profile      UserProfile?
  vision       UserVision?
  credits      Credits? // Legacy MVP1, keep for now or migrate to Plan logic
  
  // Agent Relations
  matches      JobMatch[]
  applications Application[]
  agentTasks   AgentTask[]
  generations  Generation[]

  @@map("users")
}

model Subscription {
  id                   String    @id @default(uuid())
  userId               String    @unique @map("user_id")
  stripeCustomerId     String?   @map("stripe_customer_id")
  stripeSubscriptionId String?   @unique @map("stripe_subscription_id")
  planCode             String    @map("plan_code") // "BASIC", "PRO"
  status               String    // "active", "past_due", "canceled", "incomplete"
  currentPeriodEnd     DateTime? @map("current_period_end")
  updatedAt            DateTime  @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}

model Credits {
  id              String   @id @default(uuid())
  userId          String   @unique @map("user_id")
  freeCredits     Int      @default(5)
  isSubscribed    Boolean  @default(false) 
  subscriptionEnd DateTime?
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@map("credits")
}

// ============================================
// 2. PROFILE & VISION (VEE)
// ============================================

model UserProfile {
  userId             String   @id @map("user_id")
  educationLevel     String?  @map("education_level") 
  fieldOfStudy       String?  @map("field_of_study")
  skills             String[] // Array of strings
  languages          String[] 
  preferredLocations String[] @map("preferred_locations")
  bio                String?  @db.Text
  updatedAt          DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_profiles")
}

model UserVision {
  userId             String   @id @map("user_id")
  dreams             String?  @db.Text
  constraints        String?  @db.Text
  preferredIndustries String[] @map("preferred_industries")
  targetRoles        String[] @map("target_roles")
  alterGoal          String?  @map("alter_goal") // "Signer avant septembre"
  updatedAt          DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_visions")
}

// ============================================
// 3. MARKET & MATCHING (The Agent)
// ============================================

model JobOffer {
  id          String   @id @default(uuid())
  source      String   // "MANUAL", "SCRAPER_V1", "PARTNER"
  sourceRef   String?  @map("source_ref") // ID in external system
  url         String   @unique
  title       String
  company     String
  location    String?
  description String?  @db.Text
  tags        String[]
  publishedAt DateTime? @map("published_at")
  scrapedAt   DateTime @default(now()) @map("scraped_at")

  // Relations
  matches     JobMatch[]
  applications Application[]

  @@index([source, sourceRef])
  @@map("job_offers")
}

model JobMatch {
  id             String   @id @default(uuid())
  userId         String   @map("user_id")
  jobOfferId     String   @map("job_offer_id")
  scoreTotal     Int      // 0-100
  scoreBreakdown Json?    @map("score_breakdown") // { skills: 30, location: 20 ... }
  explanation    String?  @db.Text
  createdAt      DateTime @default(now()) @map("created_at")

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  jobOffer JobOffer @relation(fields: [jobOfferId], references: [id], onDelete: Cascade)

  @@unique([userId, jobOfferId])
  @@index([userId, scoreTotal(sort: Desc)])
  @@map("job_matches")
}

// ============================================
// 4. PIPELINE & TRACKING
// ============================================

enum ApplicationStatus {
  SAVED
  APPLIED
  WAITING
  INTERVIEW
  OFFER
  SIGNED
  REJECTED
}

model Application {
  id             String            @id @default(uuid())
  userId         String            @map("user_id")
  jobOfferId     String?           @map("job_offer_id") // Can be null if custom application
  externalUrl    String?           @map("external_url") // If applying to external offer not in DB
  status         ApplicationStatus @default(SAVED)
  notes          String?           @db.Text
  appliedAt      DateTime?         @map("applied_at")
  lastContactAt  DateTime?         @map("last_contact_at")
  nextActionAt   DateTime?         @map("next_action_at")
  createdAt      DateTime          @default(now()) @map("created_at")
  updatedAt      DateTime          @updatedAt @map("updated_at")

  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  jobOffer JobOffer? @relation(fields: [jobOfferId], references: [id])
  events   ApplicationEvent[]

  @@unique([userId, jobOfferId]) 
  @@index([userId, status])
  @@map("applications")
}

model ApplicationEvent {
  id            String   @id @default(uuid())
  applicationId String   @map("application_id")
  eventType     String   // "STATUS_CHANGED", "FOLLOWUP", "NOTE"
  payload       Json?    // metadata
  eventAt       DateTime @default(now()) @map("event_at")

  application Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)

  @@index([applicationId, eventAt(sort: Desc)])
  @@map("application_events")
}

// ============================================
// 5. AGENT INTERNALS
// ============================================

enum TaskStatus {
  QUEUED
  RUNNING
  SUCCESS
  FAILED
}

model AgentTask {
  id        String     @id @default(uuid())
  userId    String     @map("user_id")
  taskType  String     // "FETCH_OFFERS", "RUN_MATCH", "GENERATE_CV"
  status    TaskStatus @default(QUEUED)
  input     Json?
  output    Json?
  createdAt DateTime   @default(now()) @map("created_at")
  updatedAt DateTime   @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, status])
  @@map("agent_tasks")
}

// Legacy for MVP 1 history
model Generation {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  type      String   // "CV", "COVER_LETTER"
  input     String   @db.Text
  output    String   @db.Text
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@map("generations")
}

model StripeWebhookEvent {
  id        String   @id @default(uuid())
  eventId   String   @unique @map("event_id")
  type      String
  createdAt DateTime @default(now()) @map("created_at")
  
  @@map("stripe_webhook_events")
}
